# 《算法导论（原书第三版）》习题

## 一、基础知识
### 1.算法在计算中的作用

### 2.算法基础

### 练习

**2-3-1**  
使用图2-4作为模型，说明归并排序在数组A=(3, 41, 52, 26, 38, 57, 9, 49)上的操作。

**2-3-2**  
重写过程MERGE，使之不使用哨兵，而是一旦数组L或R的所有元素均复制回A就立即停止，然后把另一个数组的剩余部分复制回A。

c2:mergesort.c

```c
void
merge(int a[], int p, int mid, int q) {
    int llenth = mid - p + 1, rlenth = q - mid;
    int l[llenth], r[rlenth];
    for (int j = 0; j < llenth; ++j) {
        l[j] = a[p + j];
    }
    for (int j = 0; j < rlenth; ++j) {
        r[j] = a[mid + 1 + j];
    }

    int j = p, x = 0, y = 0;
    for (; j <= q; ++j) {
        if (x == llenth || y == rlenth) {
            break;
        }
        if (l[x] < r[y]) {
            a[j] = l[x];
            ++x;
        } else {
            a[j] = r[y];
            ++y;
        }
    }
    if (x == llenth) {
        while (j <= q) {
            a[j] = r[y];
            ++j;
            ++y;
        }
    }
    if (y == rlenth) {
        while (j <= q) {
            a[j] = l[x];
            ++j;
            ++x;
        }
    }
}

void
mergesort(int a[], int p, int q) {
    if (p < q) {
        int mid = (p + q) / 2;
        mergesort(a, p, mid);
        mergesort(a, mid + 1, q);
        merge(a, p, mid, q);
    }
}
```

**2-3-3**  
使用数学归纳法证明：当n是2的幂时，对T(n)的解是T(n) = n*lg(n)。

**2-3-4**  
我们可以根据练习2.3-2中的归并过程，为了排序A[1...n]，我们递归地排序A[1...n/2]，然后把它们插入已排序的数组A[n/2+1...n]。为插入排序的这个递归版本编写一个伪代码。

**2-3-5**  
证明：假设数组A已经以非降序排列，证明归并排序的最坏情况运行时间是Θ(n*lg(n))。

**2-3-6**  
注意图2-1中的过程INSERTION-SORT的第5~7行的while循环采用一种线性查找方法。我们可以使用二分查找方法来改进插入排序的最坏情况运行时间吗？

**2-3-7**  
指出一个运行时间为O(n*lg(n))的算法，给定一个整数集合S和另一个整数x，该算法确定S中是否存在两个其和刚好为x的元素。

### 思考题

**2-1**  
在归并排序中对较小数组采用插入排序。虽然归并排序的最坏情况运行时间为Θ(n*lg(n))，而插入排序的最坏情况运行时间为Θ(n^2)，但是插入排序的常量因子可能使得
它在一个较小的子数组上排序时实际运作得更快。因此，在归并排序中当子数组变得足够小的时候，切换到插入排序是有意义的。考虑归并排序的一种变化，其中使用插入
排序来排序长度为k的小子数组，然后使用标准的合并机制合并这些子数组，这里k是一个待定的值。

a. 证明：插入排序最坏情况可以在 \(Θ(nk)\) 时间内排序每个长度为 \(n/k\) 的子表。

b. 表明在最坏情况下如何在 \(Θ(n \log(n/k))\) 时间内合并这些子表。

c. 假定修改后的算法的最坏情况运行时间为 \(Θ(nk + n \log(n/k))\)，要使修改后的算法与标准的归并排序具有相同的运行时间，作为 \(n\) 的一个函数，借助 \(Θ\) 记号，\(k\) 的最大值是什么？

d. 在实践中，我们应该如何选择 \(k\)？

**2-3**  
（冒泡排序的正确性）冒泡排序是一种流行但低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素。

```
BUBBLESORT(A)
1. for i = 1 to A.length - 1
2.     for j = A.length downto i + 1
3.         if A[j] < A[j - 1]
4.             exchange A[j] with A[j - 1]
```

a. 假设 \(A'\) 表示 BUBBLESORT(A) 的输出。为了证明 BUBBLESORT 正确，我们必须证明它将终止并且有：

\[ A'[1] \leq A'[2] \leq \ldots \leq A'[n] \]

其中 \(n = A.length\)。为了证明 BUBBLESORT 确实完成了排序，我们还需要证明什么？

b. 为第2~4行的for循环精确地说明一个循环不变式，并证明该循环不变式成立。你的证明应该使用本章中给出的循环不变式证明的结构。

c. 使用（b）部分证明的循环不变式的终止条件，为第1~4行的for循环说明一个循环不变式，该不变式将使你能证明不等式（2.3）。你的证明应该使用本章中给出的循环不变式证明的结构。

d. 冒泡排序的最坏情况运行时间是多少？与插入排序的运行时间相比，其性能如何？

### 思考题

**2-3**  
（霍纳（Horner）规则的正确性）给定系数 \(a_0, a_1, \ldots, a_n\) 和 \(x\) 的值，代码片段

```
1. y = 0
2. for i = n downto 0
3.     y = a_i + x \cdot y
```

实现了用于求值多项式

\[ P(x) = \sum_{k=0}^{n} a_k x^k = a_0 + x(a_1 + x(a_2 + \ldots + x(a_{n-1} + x a_n)) \]

的霍纳规则。

a. 借助 \(Θ\) 记号，实现霍纳规则的以上代码片段的运行时间是多少？

b. 编写伪代码来实现朴素的多项式求值算法，该算法从头开始计算多项式的每个项。该算法的运行时间是多少？与霍纳规则相比，其性能如何？

c. 考虑以下循环不变式：在第2~3行for循环每次迭代的开始有

\[ y = \sum_{k=0}^{i} a_k x^k \]

把没有项的和式解释为等于0。遵照本章中给出的循环不变式证明的结构，使用该循环不变式来证明终止时有

\[ y = \sum_{k=0}^{n} a_k x^k \]

d. 最后证明上面给出的代码片段将正确地求由系数 \(a_0, a_1, \ldots, a_n\) 刻画的多项式的值。


### 3.函数的增长

### 4.分治策略

### 5.概率分析和随机算法

## 二、排序和顺序统计量
### 6.概率分析和随机算法
## 三、数据结构
## 四、高级设计和分析技术
## 五、高级数据结构
## 六、图算法
## 七、算法问题选编
## 2.算法基础